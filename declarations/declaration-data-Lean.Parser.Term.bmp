{"name":"Lean.Parser.Term","instances":[{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","className":"Coe"},{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","className":"Coe"}],"imports":["Init","Lean.Parser.Attr","Lean.Parser.Level"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L683-L684","name":"Lean.Parser.Tactic.quotSeq","line":683,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quotSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L681-L682","name":"Lean.Parser.Tactic.quot","line":681,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L676-L677","name":"Lean.Parser.Term.dotIdent","line":676,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dotIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L673-L674","name":"Lean.Parser.Term.dynamicQuot","line":673,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dynamicQuot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L670-L671","name":"Lean.Parser.Term.stateRefT","line":670,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">stateRefT</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L667-L667","name":"Lean.Parser.Term.macroLastArg","line":667,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroLastArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L666-L666","name":"Lean.Parser.Term.macroDollarArg","line":666,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroDollarArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L665-L665","name":"Lean.Parser.Term.macroArg","line":665,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">macroArg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L661-L662","name":"Lean.Parser.Term.assert","line":661,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.assert","doc":"`assert! cond` panics if `cond` evaluates to `false`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.assert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">assert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L657-L659","name":"Lean.Parser.Term.dbgTrace","line":657,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace","doc":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">dbgTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L651-L652","name":"Lean.Parser.Term.unreachable","line":651,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable","doc":"A shorthand for `panic! \"unreachable code has been reached\"`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unreachable</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L648-L649","name":"Lean.Parser.Term.panic","line":648,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.panic","doc":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.panic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">panic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L638-L638","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","line":638,"kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil_1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinderF</span></span>) (<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.bracketedBinder</span></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L637-L637","name":"Lean.Parser.Term.bracketedBinderF","line":637,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinderF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L634-L635","name":"Lean.Parser.Term.subst","line":634,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.subst","doc":"`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation\nwhere you change the type of `e` by using `h`.\nSee the Chapter \"Quantifiers and Equality\" in the manual\n\"Theorem Proving in Lean\" for additional information.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.subst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">subst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L623-L624","name":"Lean.Parser.Term.pipeCompletion","line":623,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeCompletion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L621-L622","name":"Lean.Parser.Term.pipeProj","line":621,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj","doc":"`e |>.x` is a shorthand for `(e).x`.\nIt is especially useful for avoiding parentheses with repeated applications.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">pipeProj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L612-L615","name":"Lean.Parser.Term.namedPattern","line":612,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern","doc":"`x@e` matches the pattern `e` and binds its value to the identifier `x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L607-L610","name":"Lean.Parser.Term.explicitUniv","line":607,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv","doc":"`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitUniv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L602-L604","name":"Lean.Parser.Term.isIdent","line":602,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">isIdent</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L599-L600","name":"Lean.Parser.Term.arrow","line":599,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.arrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.arrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">arrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L597-L598","name":"Lean.Parser.Term.completion","line":597,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.completion","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.completion\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">completion</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L595-L596","name":"Lean.Parser.Term.proj","line":595,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.proj","doc":"The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.proj\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">proj</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L581-L581","name":"Lean.Parser.Term.app","line":581,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.app\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.TrailingParser\">Lean.Parser.TrailingParser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L574-L577","name":"Lean.Parser.Term.argument","line":574,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.argument","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.argument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">argument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L572-L573","name":"Lean.Parser.Term.ellipsis","line":572,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ellipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L570-L571","name":"Lean.Parser.Term.namedArgument","line":570,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">namedArgument</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L567-L568","name":"Lean.Parser.Term.noErrorIfUnused","line":567,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused","doc":"Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noErrorIfUnused</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L560-L561","name":"Lean.Parser.Term.defaultOrOfNonempty","line":560,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">defaultOrOfNonempty</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L557-L558","name":"Lean.Parser.Term.waitIfContainsMVar","line":557,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L555-L556","name":"Lean.Parser.Term.waitIfTypeContainsMVar","line":555,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeContainsMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L553-L554","name":"Lean.Parser.Term.waitIfTypeMVar","line":553,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">waitIfTypeMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L551-L552","name":"Lean.Parser.Term.letMVar","line":551,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letMVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L548-L549","name":"Lean.Parser.Term.clear","line":548,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.clear","doc":"`clear% x; e` elaborates `x` after clearing the free variable `x` from the local context.\nIf `x` cannot be cleared (due to dependencies), it will keep `x` without failing.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L541-L542","name":"Lean.Parser.Term.noImplicitLambda","line":541,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noImplicitLambda</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L539-L540","name":"Lean.Parser.Term.ensureExpectedType","line":539,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureExpectedType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L537-L538","name":"Lean.Parser.Term.ensureTypeOf","line":537,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ensureTypeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L535-L536","name":"Lean.Parser.Term.typeOf","line":535,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeOf</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L533-L534","name":"Lean.Parser.Term.withDeclName","line":533,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName","doc":"* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withDeclName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L525-L525","name":"Lean.Parser.Term.declName","line":525,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.declName","doc":"A macro which evaluates to the name of the currently elaborating declaration. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.declName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">declName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L521-L522","name":"Lean.Parser.Term.forInMacro'","line":521,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L519-L520","name":"Lean.Parser.Term.forInMacro","line":519,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forInMacro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L516-L517","name":"Lean.Parser.Term.unop","line":516,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.unop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">unop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L514-L515","name":"Lean.Parser.Term.binop_lazy","line":514,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop_lazy</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L512-L513","name":"Lean.Parser.Term.binop","line":512,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L510-L511","name":"Lean.Parser.Term.binrel_no_prop","line":510,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop","doc":"Similar to `binrel`, but coerce `Prop` arguments into `Bool`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel_no_prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L507-L508","name":"Lean.Parser.Term.binrel","line":507,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binrel\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binrel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L504-L505","name":"Lean.Parser.Term.noindex","line":504,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noindex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.noindex\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">noindex</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L501-L502","name":"Lean.Parser.Term.matchAltsWhereDecls","line":501,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltsWhereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L497-L498","name":"Lean.Parser.Term.whereDecls","line":497,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">whereDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L492-L494","name":"Lean.Parser.Term.letrec","line":492,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letrec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letrec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letrec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L489-L490","name":"Lean.Parser.Term.letRecDecls","line":489,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecls</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L487-L488","name":"Lean.Parser.Term.letRecDecl","line":487,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letRecDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L485-L486","name":"Lean.Parser.Term.attributes","line":485,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attributes","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attributes\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attributes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L483-L483","name":"Lean.Parser.Term.attrInstance","line":483,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrInstance</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L482-L482","name":"Lean.Parser.Term.attrKind","line":482,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">attrKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L481-L481","name":"Lean.Parser.Term.local","line":481,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.local","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.local\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">local</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L480-L480","name":"Lean.Parser.Term.scoped","line":480,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scoped","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scoped\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scoped</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L477-L478","name":"Lean.Parser.Term.have","line":477,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.have","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.have\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">have</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L475-L476","name":"Lean.Parser.Term.haveDecl","line":475,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L473-L474","name":"Lean.Parser.Term.haveEqnsDecl","line":473,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveEqnsDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L471-L472","name":"Lean.Parser.Term.haveIdDecl","line":471,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveIdDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L470-L470","name":"Lean.Parser.Term.haveIdLhs","line":470,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">haveIdLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L466-L467","name":"Lean.Parser.Term.let_tmp","line":466,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp","doc":"`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_tmp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L460-L461","name":"Lean.Parser.Term.let_delayed","line":460,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed","doc":"`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_delayed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L455-L456","name":"Lean.Parser.Term.let_fun","line":455,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun","doc":"`let_fun x := v; b` is syntax sugar for `(fun x => b) v`.\nIt is very similar to `let x := v; b`, but they are not equivalent.\nIn `let_fun`, the value `v` has been abstracted away and cannot be accessed in `b`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let_fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L448-L449","name":"Lean.Parser.Term.let","line":448,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let","doc":"`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.let\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">let</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L424-L426","name":"Lean.Parser.Term.letDecl","line":424,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L420-L421","name":"Lean.Parser.Term.letEqnsDecl","line":420,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letEqnsDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L402-L403","name":"Lean.Parser.Term.letPatDecl","line":402,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letPatDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L400-L401","name":"Lean.Parser.Term.letIdDecl","line":400,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L396-L399","name":"Lean.Parser.Term.letIdLhs","line":396,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdLhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L392-L394","name":"Lean.Parser.Term.letIdBinder","line":392,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">letIdBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L389-L390","name":"Lean.Parser.Term.doubleQuotedName","line":389,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName","doc":"A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">doubleQuotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L382-L382","name":"Lean.Parser.Term.quotedName","line":382,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName","doc":"A literal of type `Name`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">quotedName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L379-L380","name":"Lean.Parser.Term.borrowed","line":379,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">borrowed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L376-L377","name":"Lean.Parser.Term.trailing_parser","line":376,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trailing_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L374-L375","name":"Lean.Parser.Term.leading_parser","line":374,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">leading_parser</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L371-L373","name":"Lean.Parser.Term.withAnonymousAntiquot","line":371,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">withAnonymousAntiquot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L370-L370","name":"Lean.Parser.Term.optExprPrecedence","line":370,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optExprPrecedence</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L367-L368","name":"Lean.Parser.Term.fun","line":367,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L365-L366","name":"Lean.Parser.Term.basicFun","line":365,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">basicFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L360-L362","name":"Lean.Parser.Term.funBinder","line":360,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L355-L359","name":"Lean.Parser.Term.funStrictImplicitBinder","line":355,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funStrictImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L353-L354","name":"Lean.Parser.Term.funImplicitBinder","line":353,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">funImplicitBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L351-L351","name":"Lean.Parser.Term.nomatch","line":351,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch","doc":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">nomatch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L343-L345","name":"Lean.Parser.Term.match","line":343,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.match","doc":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.match\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">match</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L309-L311","name":"Lean.Parser.Term.motive","line":309,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.motive","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.motive\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">motive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L305-L307","name":"Lean.Parser.Term.generalizingParam","line":305,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">generalizingParam</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L304-L304","name":"Lean.Parser.Term.falseVal","line":304,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">falseVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L303-L303","name":"Lean.Parser.Term.trueVal","line":303,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">trueVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L300-L301","name":"Lean.Parser.Term.matchDiscr","line":300,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchDiscr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L297-L298","name":"Lean.Parser.Term.matchAlts","line":297,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> <span class=\"fn\">Lean.Parser.termParser</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L294-L295","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","line":294,"kind":"instance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAltExpr</span></span>) (<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Term.matchAlt</span></span>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L292-L292","name":"Lean.Parser.Term.matchAltExpr","line":292,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr","doc":"Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... => $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAltExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L283-L288","name":"Lean.Parser.Term.matchAlt","line":283,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">matchAlt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rhsParser : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a> <span class=\"fn\">Lean.Parser.termParser</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L278-L281","name":"Lean.Parser.Term.forall","line":278,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forall","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.forall\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">forall</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L274-L275","name":"Lean.Parser.Term.depArrow","line":274,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">depArrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L254-L257","name":"Lean.Parser.Term.bracketedBinder","line":254,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">bracketedBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L252-L253","name":"Lean.Parser.Term.instBinder","line":252,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder","doc":"Instance-implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by typeclass inference of the specified class.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">instBinder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L245-L247","name":"Lean.Parser.Term.strictImplicitBinder","line":245,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder","doc":"Strict-implicit binder. In contrast to `{ ... }` regular implicit binders,\na strict-implicit binder is inserted automatically only when at least one subsequent\nexplicit parameter is specified.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L239-L239","name":"Lean.Parser.Term.strictImplicitRightBracket","line":239,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitRightBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L238-L238","name":"Lean.Parser.Term.strictImplicitLeftBracket","line":238,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">strictImplicitLeftBracket</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L236-L237","name":"Lean.Parser.Term.implicitBinder","line":236,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder","doc":"Implicit binder. In regular applications without `@`, it is automatically inserted\nand solved by unification whenever all explicit parameters before it are specified.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">implicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L230-L231","name":"Lean.Parser.Term.explicitBinder","line":230,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicitBinder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L221-L228","name":"Lean.Parser.Term.binderDefault.parenthesizer","line":221,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">Lean.PrettyPrinter.Parenthesizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L217-L218","name":"Lean.Parser.Term.binderDefault","line":217,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderDefault</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L215-L216","name":"Lean.Parser.Term.binderTactic","line":215,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L213-L214","name":"Lean.Parser.Term.binderType","line":213,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(requireType : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L211-L212","name":"Lean.Parser.Term.inaccessible","line":211,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible","doc":"`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">inaccessible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L205-L206","name":"Lean.Parser.Term.explicit","line":205,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicit","doc":"`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.explicit\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">explicit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L200-L200","name":"Lean.Parser.Term.optType","line":200,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optType","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optType\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L199-L199","name":"Lean.Parser.Term.typeSpec","line":199,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeSpec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L194-L198","name":"Lean.Parser.Term.structInst","line":194,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInst","doc":"Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInst\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInst</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L183-L184","name":"Lean.Parser.Term.optEllipsis","line":183,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optEllipsis</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L180-L182","name":"Lean.Parser.Term.structInstFieldAbbrev","line":180,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstFieldAbbrev</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L178-L179","name":"Lean.Parser.Term.structInstField","line":178,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstField</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L175-L177","name":"Lean.Parser.Term.structInstLVal","line":175,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstLVal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L173-L174","name":"Lean.Parser.Term.structInstArrayRef","line":173,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">structInstArrayRef</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L172-L172","name":"Lean.Parser.Term.show","line":172,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.show","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.show\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">show</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L170-L171","name":"Lean.Parser.Term.suffices","line":170,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.suffices","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.suffices\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">suffices</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L168-L169","name":"Lean.Parser.Term.sufficesDecl","line":168,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sufficesDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L167-L167","name":"Lean.Parser.Term.showRhs","line":167,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">showRhs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L165-L166","name":"Lean.Parser.Term.fromTerm","line":165,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">fromTerm</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L163-L164","name":"Lean.Parser.Term.optIdent","line":163,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L161-L162","name":"Lean.Parser.Term.anonymousCtor","line":161,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor","doc":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">anonymousCtor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L152-L153","name":"Lean.Parser.Term.paren","line":152,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.paren","doc":"Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.paren\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L141-L142","name":"Lean.Parser.Term.tuple","line":141,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.tuple","doc":"Tuple notation; `()` is short for `Unit.unit`, `(a, b, c)` for `Prod.mk a (Prod.mk b c)`, etc. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L138-L139","name":"Lean.Parser.Term.typeAscription","line":138,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription","doc":"Type ascription notation: `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\nAn empty type ascription `(e :)` elaborates `e` without the expected type.\nThis is occasionally useful when Lean's heuristics for filling arguments from the expected type\ndo not yield the right result.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">typeAscription</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L130-L131","name":"Lean.Parser.Term.cdot","line":130,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.cdot","doc":"A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(· + ·)` is equivalent to `fun x y => x + y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.cdot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">cdot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L124-L125","name":"Lean.Parser.Term.sorry","line":124,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sorry","doc":"A temporary placeholder for a missing proof or value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sorry\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sorry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L122-L122","name":"Lean.Parser.Term.binderIdent","line":122,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">binderIdent</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L120-L121","name":"Lean.Parser.Term.syntheticHole","line":120,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">syntheticHole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L118-L119","name":"Lean.Parser.Term.hole","line":118,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.hole","doc":"A placeholder term, to be synthesized by unification. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.hole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">hole</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L115-L116","name":"Lean.Parser.Term.prop","line":115,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.prop","doc":"The universe of propositions. `Prop ≡ Sort 0`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.prop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">prop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L112-L113","name":"Lean.Parser.Term.sort","line":112,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sort","doc":"A specific universe in Lean's infinite hierarchy of universes. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.sort\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">sort</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L109-L110","name":"Lean.Parser.Term.type","line":109,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.type","doc":"A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.type\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">type</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L106-L107","name":"Lean.Parser.Term.char","line":106,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.char","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.char\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">char</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L104-L105","name":"Lean.Parser.Term.str","line":104,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.str","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.str\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">str</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L102-L103","name":"Lean.Parser.Term.scientific","line":102,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scientific","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.scientific\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">scientific</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L100-L101","name":"Lean.Parser.Term.num","line":100,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.num","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.num\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">num</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L98-L99","name":"Lean.Parser.Term.ident","line":98,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ident","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.ident\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">ident</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L94-L95","name":"Lean.Parser.Term.optSemicolon","line":94,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">optSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L90-L91","name":"Lean.Parser.Term.byTactic'","line":90,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L81-L82","name":"Lean.Parser.Term.byTactic","line":81,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic","doc":"`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Term</span>.<span class=\"name\">byTactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L74-L74","name":"Lean.Parser.semicolonOrLinebreak","line":74,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">semicolonOrLinebreak</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L73-L73","name":"Lean.Parser.darrow","line":73,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.darrow","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.darrow\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">darrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L68-L69","name":"Lean.Parser.Tactic.seq1","line":68,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">seq1</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L64-L65","name":"Lean.Parser.Tactic.tacticSeqIndentGt","line":64,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt","doc":"Same as [`tacticSeq`] but requires delimiter-free tactic sequence to have strict indentation.\nThe strict indentation requirement only apply to *nested* `by`s, as top-level `by`s do not have a\nposition set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqIndentGt\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqIndentGt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L58-L59","name":"Lean.Parser.Tactic.tacticSeq","line":58,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq","doc":"A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics.\nDelimiter-free indentation is determined by the *first* tactic of the sequence. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L53-L54","name":"Lean.Parser.Tactic.tacticSeqBracketed","line":53,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed","doc":"The syntax `{ tacs }` is an alternative syntax for `· tacs`.\nIt runs the tactics in sequence, and fails if the goal is not solved. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeqBracketed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L49-L50","name":"Lean.Parser.Tactic.tacticSeq1Indented","line":49,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSeq1Indented</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L42-L43","name":"Lean.Parser.Tactic.sepBy1IndentSemicolon","line":42,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepBy1IndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L38-L39","name":"Lean.Parser.Tactic.sepByIndentSemicolon","line":38,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">sepByIndentSemicolon</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L32-L33","name":"Lean.Parser.convParser","line":32,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.convParser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.convParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">convParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rbp : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L29-L30","name":"Lean.Parser.tacticParser","line":29,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.tacticParser","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.tacticParser\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">tacticParser</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(rbp : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L21-L22","name":"Lean.Parser.Command.docComment","line":21,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.docComment","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.docComment\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">docComment</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L19-L19","name":"Lean.Parser.Command.commentBody.formatter","line":19,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">formatter</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Formatter.html#Lean.PrettyPrinter.Formatter\">Lean.PrettyPrinter.Formatter</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L17-L17","name":"Lean.Parser.Command.commentBody.parenthesizer","line":17,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span>.<span class=\"name\">parenthesizer</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/PrettyPrinter/Parenthesizer.html#Lean.PrettyPrinter.Parenthesizer\">Lean.PrettyPrinter.Parenthesizer</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/ec941735c80dc54c53948e30c428905b6600f95a/src/Lean/Parser/Term.lean#L13-L14","name":"Lean.Parser.Command.commentBody","line":13,"kind":"def","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Command</span>.<span class=\"name\">commentBody</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Parser/Types.html#Lean.Parser.Parser\">Lean.Parser.Parser</a></div></div>"}]}